(window.webpackJsonp=window.webpackJsonp||[]).push([[34,3],{447:function(e,t,n){"use strict";n.r(t);var r={name:"Content",props:{title:{type:String,default:""},date:{type:String,default:""},content:{type:Array,default:function(){return[]}},reference:{type:Array,default:function(){return[]}},source:{type:Array,default:function(){return[]}}},data:function(){return{}},mounted:function(){},methods:{}},l=n(75),c=n(90),o=n.n(c),m=n(454),y=n(444),d=n(546),h=(n(11),n(12),n(10),n(5),n(15),n(9),n(16),n(2)),v=(n(24),n(117),n(452),n(98)),f=n(28),_=n(35),x=n(7),E=n(0);function P(object,e){var t=Object.keys(object);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(object);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(object,e).enumerable}))),t.push.apply(t,n)}return t}var w=Object(x.a)(Object(v.a)("bar",["height","window"]),f.a,_.a).extend({name:"v-system-bar",props:{height:[Number,String],lightsOut:Boolean,window:Boolean},computed:{classes:function(){return function(e){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?P(Object(source),!0).forEach((function(t){Object(h.a)(e,t,source[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(source)):P(Object(source)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(source,t))}))}return e}({"v-system-bar--lights-out":this.lightsOut,"v-system-bar--absolute":this.absolute,"v-system-bar--fixed":!this.absolute&&(this.app||this.fixed),"v-system-bar--window":this.window},this.themeClasses)},computedHeight:function(){return this.height?isNaN(parseInt(this.height))?this.height:parseInt(this.height):this.window?32:24},styles:function(){return{height:Object(E.h)(this.computedHeight)}}},methods:{updateApplication:function(){return this.$el?this.$el.clientHeight:this.computedHeight}},render:function(e){var data={staticClass:"v-system-bar",class:this.classes,style:this.styles,on:this.$listeners};return e("div",this.setBackgroundColor(this.color,data),Object(E.s)(this))}}),component=Object(l.a)(r,(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("v-container",[n("div",{staticClass:"main"},[n("div",{staticClass:"title"},[n("h1",[e._v(e._s(e.title))]),e._v("\n      "+e._s(e.date)+"\n    ")]),e._v(" "),n("hr",{staticStyle:{height:"1px",border:"none","background-color":"white"}}),e._v(" "),n("div",{staticClass:"content",staticStyle:{"margin-bottom":"50px"}},[n("div",{staticStyle:{"margin-top":"30px"}},e._l(e.content,(function(t,i){return n("div",{key:i},[""!==t.title?n("h3",{staticStyle:{margin:"0px 0 5px 0"}},[i>0?n("br"):e._e(),e._v("\n            #"+e._s(t.title)+" \n          ")]):e._e(),e._v(" "),"I"===t.type?n("div",{staticStyle:{margin:"10px 0 10px 10px"}},[n("img",{attrs:{src:t.scr,alt:""}})]):e._e(),e._v(" "),"P"===t.type?n("div",{staticStyle:{margin:"10px 0 10px 10px"}},[n("pre",[e._v(e._s(t.scr)),""!==t.link?n("span",[n("a",{attrs:{href:t.link}},[e._v(e._s(t.link))])]):e._e()])]):e._e(),e._v(" "),"C"===t.type?n("v-card",{staticStyle:{margin:"10px 10px 10px 10px"},attrs:{color:"#333333"}},[n("v-system-bar",{attrs:{color:"#222222"}},[e._v(" Code ")]),e._v(" "),n("pre",{staticStyle:{margin:"10px"}},[e._v(e._s(t.scr))])],1):e._e(),e._v(" "),"T"===t.type?n("v-data-table",{staticStyle:{margin:"10px 10px 20px 10px"},attrs:{headers:t.scr.headers,items:t.scr.desserts,"items-per-page":t.scr.desserts.length,"hide-default-footer":""}}):e._e(),e._v(" "),"L"===t.type?n("ul",e._l(t.scr.parent,(function(r){return n("li",{key:r},[e._v("\n              "+e._s(r)+"\n              "),t.scr.children.length>0?n("ul",e._l(t.scr.children,(function(t){return n("li",{key:t},[e._v("\n                "+e._s(t)+"\n                ")])})),0):e._e()])})),0):e._e()],1)})),0),e._v(" "),e.source.length>0?n("h3",{staticStyle:{"margin-top":"50px"}},[e._v("#참고")]):e._e(),e._v(" "),e._l(e.source,(function(t){return n("div",{key:t.url},[n("h4",[n("a",{attrs:{href:t.url}},[e._v(e._s(t.url)+" "),""!==t.title?n("span",{staticStyle:{color:"white"}},[e._v(" ["+e._s(t.title)+"]")]):e._e()])])])})),e._v(" "),e.reference.length>0?n("h3",{staticStyle:{"margin-top":"50px"}},[e._v("#출처")]):e._e(),e._v(" "),e._l(e.reference,(function(t){return n("div",{key:t.url},[n("h4",[n("a",{attrs:{href:t.url}},[e._v(e._s(t.url)+" "),""!==t.title?n("span",{staticStyle:{color:"white"}},[e._v(" ["+e._s(t.title)+"]")]):e._e()])])])}))],2),e._v(" "),n("script",{attrs:{src:"https://utteranc.es/client.js",repo:"choongbeom/choongbeom.github.io","issue-term":"pathname",theme:"github-light",crossorigin:"anonymous",async:""}})])])}),[],!1,null,null,null);t.default=component.exports;o()(component,{VCard:m.a,VContainer:y.a,VDataTable:d.a,VSystemBar:w})},452:function(e,t,n){var content=n(453);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,n(18).default)("dd2325f0",content,!0,{sourceMap:!1})},453:function(e,t,n){var r=n(17)(!1);r.push([e.i,".theme--light.v-system-bar{background-color:#e0e0e0;color:rgba(0,0,0,.6)}.theme--light.v-system-bar .v-icon{color:rgba(0,0,0,.6)}.theme--light.v-system-bar--lights-out{background-color:hsla(0,0%,100%,.7)!important}.theme--dark.v-system-bar{background-color:#000;color:hsla(0,0%,100%,.7)}.theme--dark.v-system-bar .v-icon{color:hsla(0,0%,100%,.7)}.theme--dark.v-system-bar--lights-out{background-color:rgba(0,0,0,.2)!important}.v-system-bar{align-items:center;display:flex;font-size:.875rem;font-weight:400;padding:0 8px}.v-system-bar .v-icon{font-size:1rem;margin-right:4px}.v-system-bar--absolute,.v-system-bar--fixed{left:0;top:0;width:100%;z-index:3}.v-system-bar--fixed{position:fixed}.v-system-bar--absolute{position:absolute}.v-system-bar--window .v-icon{font-size:1.25rem;margin-right:8px}",""]),e.exports=r},576:function(e,t,n){"use strict";n.r(t);var r={name:"Entity",components:{Content:n(447).default},data:function(){return{title:"Entity와 EntityManager와 EntityManagerFactory",date:"2021-11-02",content:[{title:"Entity",type:"P",scr:"DB의 테이블과 매칭이 되는 개념이라고 보면 된다.\n그렇다면 왜 이름이 Table이 아니라 Entity일까…?\n\n만약 DB에 member라는 테이블이 있고, 해당 테이블의 스키마가 아래와 같다고 해보자."},{title:"",type:"C",scr:"CREATE TABLE 'Member' (\n  'id' BIGINT(20) unsigned NOT NULL AUTO_INCREMENT,\n  'name' varchar(255) NOT NULL,\n  'age' int(11) NOT NULL,\n  PRIMARY KEY ('id')\n)"},{title:"",type:"P",scr:"그렇다면 엔티티는 아래와 같이 만들 수 있다."},{title:"",type:"C",scr:"@Entity\npublic class Member {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    @Column(nullable = false)\n    private long id;\n    \n    @Column(nullable = false)\n    private String name;\n    \n    @Column(nullable = false)\n    private int age;\n    \n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}"},{title:"",type:"P",scr:"기본적으로 JPA는 모든 필드를 불러오게 끔 구현돼있다.\n하지만 모든 케이스에서 id, name, age 필드를 다 다루지 않는다.\n어떤 경우에는 id, name 필드만 다루는 경우도 있을 수 있다.\n그런 경우에 대비해서 다음과 같이 엔티티 클래스를 하나 더 만들 수 있다."},{title:"",type:"C",scr:'@Entity\n@Table(name = "Member")\npublic class MemberOnlyName {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    @Column(nullable = false)\n    private long id;\n    \n    @Column(nullable = false)\n    private String name;\n    \n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}'},{title:"",type:"P",scr:"따라서 테이블은 한 개지만, 엔티티는 경우에 따라서 여러 개를 만들 수 있다.\n혹은 JPA를 좀 더 잘 다룬다면 하나의 엔티티로도 충분히 커버를 할 수 있기도 하다."},{title:"EntityManager",type:"P",scr:"위에 언급한 엔티티를 관리하는 역할을 수행하는 클래스이다.\n그럼 어떤 방식으로 엔티티 매니저는 엔티티들을 관리할까?\n엔티티 매니저 내부에 영속성 컨텍스트(Persistence Context)라는 걸 두어서 엔티티들을 관리한다."},{title:"",type:"I",scr:"https://github.com/choongbeom/choongbeom.github.io/blob/master/_posts/IMG/3E.png?raw=true"},{title:"영속성 컨텍스트(Persistence Context)",type:"L",scr:{parent:["영속성"],children:["기본적으로 컴퓨터 공학에서 영속성이라고 하면 비휘발성이라고 보면 될 것 같다.","휘발성은 프로그램이 꺼지거나 전원이 나가면 데이터가 날아가는 경우를 휘발성이라 하고, 그 반대가 비휘발성이다.","휘발성과 비휘발성이란 단어는 저장 장치(메인 메모리나 플래시 메모리 등등)의 특징을 나타낼 때 많이 쓰고, 영속성이란 단어는 DB에 관해 설명할 때 많이 사용하는 것 같다."]}},{title:"",type:"L",scr:{parent:["컨텍스트"],children:["직역하면 맥락, 문맥이란 이며, 프로그래밍에서는 하나의 환경, 장소로 이해하면 될 것 같다."]}},{title:"",type:"P",scr:"하지만 개발자가 직접 영속성 컨텍스트를 뜯어보거나 그 내부를 들여다 볼 수는 없어서 약간은 논리적이거나 추상적인 개념으로 바라봐야한다.\n\n여러 엔티티 매니저가 하나의 영속성 컨텍스트를 공유할 수도 있다고 한다.\n그리고 영속성 컨텍스트를 책의 저자는 엔티티를 영구히 저장하는 환경이라고 했는데 내가 봤을 때는 영속성 컨텍스트를 관리하는 모든 엔티티 매니저가 초기화 및 종료되지 않는 한 엔티티를 영구히 저장하는 환경이라고 정정해야할 것 같다.\n그냥 영구히 저장 된다고 하면 프로그램을 껐다 켜도 영속성 컨텍스트는 항상 살아 있을 것 같다는 생각이 든다.\n하지만 프로그램을 끄기도 전에 엔티티 매니저를 초기화 및 종료 시키는 코드를 만나면 해당 영속성 컨텍스트는 소멸된다."},{title:"엔티티 매니저와 영속성 컨텍스트의 엔티티 관리",type:"P",scr:"그럼 엔티티 매니저와 영속성 컨텍스트는 어떻게 엔티티를 관리할까?\n우선 한 명의 멤버를 추가하는 코드를 살펴보자."},{title:"",type:"C",scr:"public class Join {\n    public void join(String name, int age) {\n        // 아직까지는 해당 엔티티를 엔티티 매니저가 관리하지 않는다.\n        Member member = new Member();\n        member.setName(name);\n        member.setAge(age);\n        \n        // 엔티티 매니저가 있다고 가정.\n        // 추후에 엔티티 매니저 팩토리와 함께 엔티티 매니저를 어떻게 생성하는지 설명.\n        EntityManager em;\n        EntityTransaction tx = em.getTransaction();\n        \n        try {\n            // 엔티티 매니저에서 수행하는 모든 로직은 트랜잭선 안에서 수행돼야 한다.\n            tx.begin();\n            \n            // 이렇게 하면 해당 엔티티 매니저의 영속성 컨텍스트에 위에서 만든 member 객체가 저장된다.  \n            // 이제 member 엔티티는 엔티티 매니저의 관리 대상이 되고, 영속성을 가졌다고 말할 수 있다.\n            em.persist(member);\n            \n            // 트랜잭션을 커밋한다.\n            tx.commit();\n        } catch(Exception e) {\n            // 어떤 이유에서 오류가 났다면 트랜잭션을 롤백 시켜줘야한다.\n            tx.rollback();\n        } finally {\n            // 엔티티 매니저를 종료시켜줘야 한다.  \n            // 아마 더 이상 사용하지 않는 자원이므로 더 이상 사용하지 않는 자원이라고 표시하는 것 같다.\n            // 그럼 아마 GC가 해당 엔티티 매니저 자원을 수거해가서 메모리에 반환하지 않을까??\n            // 성능 상 문제가 있어서 이렇게 종료시켜줘야 하는 건지 모르겠다. \n            em.close();\n        }\n    }\n}"},{title:"",type:"P",scr:"여기서 두 가지 설명하지 않은 개념이 있다.\n엔티티가 영속성을 가졌을 때의 특징(엔티티의 생명주기)와 트랜잭션이다.\n엔티티의 생명 주기는 나중에 엔티티 매니저를 사용하는 이유와 관련해서 따로 정리해야겠다."},{title:"트랜잭션(Transaction)",type:"P",scr:"하나의 작업 단위라고 보면 될 것 같다.\n예를 들면 “상품 구매”라는 하나의 작업을 보면 아래와 같은 자잘한 작업들이 존재한다."},{title:"",type:"L",scr:{parent:["상품의 재고 조회","유저의 잔고 조회","상품의 재고 -1","유저의 잔고에서 돈을 뺌.","주문 생성"],children:[]}},{title:"",type:"P",scr:"이런 5개의 작업은 중간에 하나라도 뻑나면 작업 전체가 뻑났다고 보고 아예 맨 처음 상태로 돌려야한다.\n4번에서 뻑났을 때 상품의 재고도 -1 했던 걸 원래 처음 상태로 돌려놔야 정상적인 작동이라고 말할 수 있다.\n이렇게 오류가 났을 때 처음 상태로 돌아가는(rollback) 작업의 단위를 트랜잭션이라고 한다.\n트랜잭션이 모두 정상적으로 수행됐을 때는 commit을 수행해서 작업 내용을 실제 DB와 엔티티 매니저에 반영한다.\n\n그럼 JPA에서 모든 로직은 왜 트랜잭션 안에서 수행해야하는 것일까…?\n물론 조회 로직은 트랜잭션 안에서 수행해야 할 필요도 없고, 트랜잭션의 단위가 커지면 데드락 이슈에 봉착하기 때문에 최대한 트랜잭션의 단위를 작게 잡으면서 안정성을 가져가는 게 베스트다.\n그건 JPA가 쿼리를 한 방에 날리기 때문이다."},{title:"쓰기 지연 SQL 저장소",type:"P",scr:"영속성 컨텍스트 안에는 쓰기 지연 SQL 저장소라는 공간이 따로 존재한다.\n만약 아래와 같은 코드가 있다고 보자."},{title:"",type:"C",scr:"public class Join {\n    public void join(String name, int age) {\n        // 아직까지는 해당 엔티티를 엔티티 매니저가 관리하지 않는다.\n        Member member = new Member();\n        member.setName(name);\n        member.setAge(age);\n        \n        Member member2 = new Member();\n        member2.setName(name);\n        member2.setAge(age);\n        \n        // 엔티티 매니저가 있다고 가정.\n        // 추후에 엔티티 매니저 팩토리와 함께 엔티티 매니저를 어떻게 생성하는지 설명.\n        EntityManager em;\n        EntityTransaction tx = em.getTransaction();\n        \n        try {\n            // 엔티티 매니저에서 수행하는 모든 로직은 트랜잭선 안에서 수행돼야 한다.\n            tx.begin();\n            \n            // 쿼리는 전송되지 않는다.\n            em.persist(member);\n            em.persist(member2);\n            \n            // 커밋하는 시점에 쿼리가 전송된다.\n            tx.commit();\n        } catch(Exception e) {\n            // 어떤 이유에서 오류가 났다면 트랜잭션을 롤백 시켜줘야한다.\n            tx.rollback();\n        } finally {\n            // 엔티티 매니저를 종료시켜줘야 한다.  \n            // 아마 더 이상 사용하지 않는 자원이므로 더 이상 사용하지 않는 자원이라고 표시하는 것 같다.\n            // 그럼 아마 GC가 해당 엔티티 매니저 자원을 수거해가서 메모리에 반환하지 않을까??\n            // 성능 상 문제가 있어서 이렇게 종료시켜줘야 하는 건지 모르겠다. \n            em.close();\n        }\n    }\n}"},{title:"",type:"P",scr:"트랜잭션을 생각하지 않고 의식의 흐름대로 코드의 동작을 추측해보면…"},{title:"",type:"L",scr:{parent:["쿼리가 두 번 날아갈 것이다.","만약에 멤버 2를 저장하는 시점에서 롤백을 해야할 때는 날리지 않아도 될 멤버 1에 대한 삽입 쿼리를 날리게 된 격이다."],children:[]}},{title:"",type:"P",scr:"하지만 쓰기 지연 SQL 저장소 및 트랜잭션에 의해 아래와 같이 동작한다."},{title:"",type:"L",scr:{parent:["트랜잭션이 커밋 되기 직전까지 모든 쿼리문은 영속성 컨텍스트 내부의 쓰기 지연 SQL 저장소에 저장된다.","트랜잭션이 커밋되는 순간 모든 쿼리가 한 방에 날아간다.","만약 트랜잭션 내부에서 오류가 나서 롤백을 해야한다면 애초에 날리지도 않을 쿼리를 날리지도 않는다."],children:[]}},{title:"",type:"P",scr:"위와 같이 성능 이슈 때문에 모든 로직을 트랜잭션 내부에서 처리하게끔 하려는 것인 것 같다."},{title:"EntityManagerFactory",type:"P",scr:"엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다."},{title:"",type:"L",scr:{parent:["동시성(Concurrency)"],children:["유저가 체감하기에는 동시에 수행하는 거 처럼 보이지만 사실은 유저가 체감할 수 없는 짧은 시간단위로 작업들을 번갈아가면서 수행하는 것이다.","싱글 코어에서 멀티 스레드를 동작시키는 방식이다.","각 스레드들이 동시에 동작하는 거 같지만 알고 보면 스레드들이 아주 짧은 시간마다 번갈아가면서 작업을 수행하고 있는 것이다."]}},{title:"",type:"L",scr:{parent:["병렬(Parallelism)"],children:["실제로 동시에 여러 작업이 수행되는 것이다.","멀티 코어에서 멀티 스레드를 동작시키는 방식이다.","각 스레드들이 동시에 동작한다."]}},{title:"",type:"P",scr:"내가 과자 먹으려고 하는데 누가 와서 뺏어먹을 수도 있기 때문에…\n내가 데이터를 수정하고 있는데 다른 스레드에서 해당 데이터를 미리 수정해버리면 안 되기 때문…\n따라서 엔티티 매니저는 하나로 공유하면 안 되고, 상황에 따라서 계속해서 만들어줘야한다.\n그럼 이런 엔티티 매니저는 누가 만들어줄까?\n바로 엔티티 매니저 팩토리(공장)이다."},{title:"",type:"C",scr:'public class Join {\n    public void join(String name, int age) {\n        // 아직까지는 해당 엔티티를 엔티티 매니저가 관리하지 않는다.\n        Member member = new Member();\n        member.setName(name);\n        member.setAge(age);\n        \n        // META-INF/persistence.xml에서 이름이 db인 persistence-unit을 찾아서 엔티티 매니저 팩토리를 생성 \n        EntityManagerFatory emf = Persistence.createEntityManagerFactory("db");\n        EntityManager em = emf.createEntityManager();\n        EntityTransaction tx = em.getTransaction();\n        \n        try {\n            // 엔티티 매니저에서 수행하는 모든 로직은 트랜잭선 안에서 수행돼야 한다.\n            tx.begin();\n            \n            // 이렇게 하면 해당 엔티티 매니저의 영속성 컨텍스트에 위에서 만든 member 객체가 저장된다.  \n            // 이제 member 엔티티는 엔티티 매니저의 관리 대상이 되고, 영속성을 가졌다고 말할 수 있다.\n            em.persist(member);\n            \n            // 트랜잭션을 커밋한다.\n            tx.commit();\n        } catch(Exception e) {\n            // 어떤 이유에서 오류가 났다면 트랜잭션을 롤백 시켜줘야한다.\n            tx.rollback();\n        } finally {\n            // 엔티티 매니저를 종료시켜줘야 한다.  \n            // 아마 더 이상 사용하지 않는 자원이므로 메모리에 자원을 반환하지 않으면\n            // 성능 상 문제가 있어서 이렇게 종료시켜줘야 하는 건지 모르겠다. \n            em.close();\n        }\n        emf.close(); // 마찬가지로 엔티티 매니저 팩토리도 더이상 쓰지 않는다면 종료시켜줘야 한다.\n    }\n}'},{title:"",type:"P",scr:"공장(엔티티 매니저 팩토리)에서 제품(엔티티 매니저)를 찍어내는 개념이라고 보면 될 것 같다.\n엔티티 매니저 팩토리는 엔티티 매니저와 달리 여러 스레드가 동시에 접근해도 안전하다.\n단순히 엔티티 매니저만 찍어대는 녀석이기 때문이다.\n\n비용도 보면 공장을 짓는 비용은 굉장히 크다.\n그래서 엔티티 매니저 팩토리는 DB 당 하나 밖에 사용하지 않는다.\n그에 비해 공장에서 제품을 찍어내는 것은 너무나도 당연하고 빈번하게 일어나는 일이기 때문에 비용이 엄청 크게 들지 않는다."},{title:"",type:"C",scr:'public class EMF {\n    public static void main(String[] args){\n      EntityManagerFatory emf = Persistence.createEntityManagerFactory("db");\n      EntityManagerFatory emf2 = Persistence.createEntityManagerFactory("db");\n      \n      System.out.println(emf == emf2); // false\n    }\n}'},{title:"",type:"P",scr:"하지만 그냥 일반적으로 엔티티 매니저 팩토리를 사용하면 계속 새로운 엔티티 매니저 팩토리를 생성한다.\n따라서 동일한 엔티티 매니저 팩토리를 공유해서 사용하려면 싱글턴 인스턴스나 의존성 주입 등등을 통해 개발자의 의식적인 노력이 필요하다."}],source:[],reference:[{title:"오늘도 끄적끄적",url:"https://perfectacle.github.io/2018/01/14/jpa-entity-manager-factory/"}]}},mounted:function(){},methods:{}},l=n(75),c=n(90),o=n.n(c),m=n(444),component=Object(l.a)(r,(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("v-container",[n("div",[n("Content",{attrs:{title:e.title,date:e.date,content:e.content,source:e.source,reference:e.reference}})],1)])}),[],!1,null,null,null);t.default=component.exports;o()(component,{Content:n(447).default}),o()(component,{VContainer:m.a})}}]);